[{"id":0,"href":"/knowledge/docs/swift/formatters/","title":"Formatters","section":"Swift/SwiftUI","content":" Formatters # The easiest way to get a formatted element is to use the formatted method that is available on a myriad of data types without the need to instantiate our own formatter. And the best thing is that all these things are also available directly on SwiftUI controls like Text and TextField by using the format parameter.\nBelow are the most common/useful ones I\u0026rsquo;ve found so far.\nDates # In order to get a date formatted, we can simply call formatted on a Date type, which gives us the full, long formatted date:\nDate.now.formatted() // \u0026#34;7/16/2022, 1:15 PM\u0026#34; Of course this by itself is not very useful, but we can customize how we want the date to be shown by adding parameters to the function call. If we add .timeDate as a parameter we\u0026rsquo;ll get the same result, but now we can chain calls in a fluent fashion to customize the output, for example:\nDate.now.formatted( .dateTime.hour().minute() ) // \u0026#34;1:15 PM\u0026#34; Date.now.formatted( .dateTime.year().month() ) // \u0026#34;Jul 2022\u0026#34; You can also pass parameters to each individual component:\nDate.now.formatted( .dateTime.year(.twoDigits).month() ) // \u0026#34;Jul 22\u0026#34; Relative dates # Using the relative parameter, we can get how long it\u0026rsquo;s been in a relative fashion since a date:\nDate.now.addingTimeInterval(-15000).formatted( .relative(presentation: .numeric) ) // \u0026#34;4 hours ago\u0026#34; Date.now.addingTimeInterval(-15000).formatted( .relative(presentation: .numeric) ) Date ranges # If you use formatted on a range of dates, you get the duration between the two dates:\nlet now = Date.now let in16Minutes = Date.now.addingTimeInterval(1000) (now..\u0026lt;in16Minutes).formatted( .components(style: .narrow) ) // \u0026#34;16min 40sec\u0026#34; Currencies # 16.40.formatted(.currency(code: \u0026#34;EUR\u0026#34;)) // \u0026#34;â‚¬16.40\u0026#34; 25.34.formatted(.currency(code: \u0026#34;USD\u0026#34;)) // \u0026#34;$25.34\u0026#34; Sadly for this one it doesn\u0026rsquo;t seem to respect the currency\u0026rsquo;s usual symbol position and instead uses the one specified in the user\u0026rsquo;s location. In my case I have my computer language set to English US which by default positions the symbol in the left side while for Euros the symbol is usually on the right.\nNumeric # 12.formatted(.number.sign(strategy: .always())) // \u0026#34;+12\u0026#34; 12.formatted(.percent) // 12% "},{"id":1,"href":"/knowledge/docs/swift/coredata/swiftui-grouped-queries/","title":"Grouped queries in SwiftUI","section":"CoreData","content":" Grouped queries in SwiftUI # Querying # While developing Maby I needed to retrieve all events that happened, grouped by dates. Now of course I could just slap a FetchRequest and then manually group the results into a dictionary, specially given how easy it is with the grouping init, but it turns out that there\u0026rsquo;s a better way.\nSince iOS/iPadOS/tvOS 15, macOS 12 and watchOS 8 there\u0026rsquo;s a new fetch request in town called SectionedFetchRequest that allows us to specify a type to group by and an entity to group, so for example in my case I could just do the following:\n@SectionedFetchRequest\u0026lt;Date, Event\u0026gt;( sectionIdentifier: \\.start, sortDescriptors: [ SortDescriptor(\\.start, order: .reverse) ] ) private var events: SectionedFetchResults\u0026lt;Date, Event\u0026gt; start being the date property that I want to group by. With this, we can go ahead and use the results just like we would with a normal fetch request, but having to iterate two times: one for the groups, another for the items inside the group:\nForEach(events) { section in Section(header: Text(section.id, format: .dateTime)) { ForEach(section) { event in Text(event.name) } } } In the code above, section.id is the ID that we gave the SectionFetchRequest to group, so in my case it\u0026rsquo;s a date and that\u0026rsquo;s why I have to specify the .dateTime format for the text to show correctly. So the section is a struct that acts as a collection, that\u0026rsquo;s why we can both grab the ID from it but also iterate over it with ForEach.\nThis would work if you chose something else than a date to group by, for example strings, numbers and the like work great for grouping, but with dates depending on how you store them and how you want to group them you\u0026rsquo;d find an issue just like I did here: I want to group by day, not by the whole date. An event that happened the 15th of August at 14:50 is the same as it happened at 14:30 for me. In order to fix this I simply introduced this computed property in my model:\n@objc public var groupStart: Date { let components = Calendar.current.dateComponents( [.year, .month, .day], from: self.start ) return Calendar.current.date(from: components)! } This basically retrieves just the day, month and year from the date and returns a Date from it, effectively removing the time from it. With this, changing the grouping property to this computed one makes it work great:\n@SectionedFetchRequest\u0026lt;Date, Event\u0026gt;( sectionIdentifier: \\.groupStart, sortDescriptors: [ SortDescriptor(\\.start, order: .reverse) ] ) private var events: SectionedFetchResults\u0026lt;Date, Event\u0026gt; (Note that I kept the original date as the sort descriptor so that the events still show ordered by date with the time taken into account)\nImplementing onDelete # With sectioned requests there\u0026rsquo;s just a tiny more work involved to support the deletions on the items:\nForEach(events) { section in Section(header: Text(section.id, format: .dateTime)) { ForEach(section) { event in Text(event.name) } .onDelete { indexSet in indexSet.forEach { viewContext.delete(section[$0]) } } } } (Note that I\u0026rsquo;m calling the view context\u0026rsquo;s delete method directly to keep the example small, feel free to change it for your preferred way of deleting)\nBasically we need to rely on the section that we\u0026rsquo;re iterating to retrieve the items, since the indexSet that the onDelete function gives us is relative to the current group. However, since section is iterable we can just grab each element by its index, easy!\n"},{"id":2,"href":"/knowledge/docs/swift/coredata/errors-and-gotchas/unrecognized-selector-objectatindex/","title":"Unrecognized selector `objectAtIndex`","section":"Errors and gotchas","content":" Unrecognized selector objectAtIndex # 2022-06-21 22:41:30.447763+0200 App[56115:1179524] -[__NSCFSet objectAtIndex:]: unrecognized selector sent to instance 0x600003df9c20 This happened with the following code, basically when trying to do a ForEach on a property coming from a CoreData model:\nimport CoreData import SwiftUI struct BudgetView: View { @FetchRequest(entity: CategoryGroup.entity(), sortDescriptors: []) var categoryGroups: FetchedResults\u0026lt;CategoryGroup\u0026gt; var body: some View { VStack { List { ForEach(categoryGroups, id: \\.id) { group in Text(group.name) ForEach(group.categories, id: \\.id) { category in Text(category.name) } } } } } } This property is actually declared manually as an array:\npublic final class CategoryGroup: NSManagedObject, Identifiable { @NSManaged public var categories: [Category] } But even though I declared it as an array apparently the underlying type that CoreData actually puts there is an NSSet, which by default does not allow to retrieve stuff by its index (does that unrecognized selector objectAtIndex makes a bit more sense now?)\nThe easy solution is to mark the property as \u0026ldquo;Ordered\u0026rdquo; in the CoreData model. The proper solution, however, is to not interact with NSSet directly unless we can avoid it, so we can simply introduce a computed variable that transforms our property into an array (or whatever other data type we need!):\npublic var categoriesArray: [Category] { let set = categories as? Set\u0026lt;Category\u0026gt; ?? [] return set.sorted { $0.id \u0026lt; $1.id } } This casts the NSSet into an array sorting it by their ID. Now instead of doing the ForEach directly on the categories property we have to use this computed one:\nimport CoreData import SwiftUI struct BudgetView: View { @FetchRequest(entity: CategoryGroup.entity(), sortDescriptors: []) var categoryGroups: FetchedResults\u0026lt;CategoryGroup\u0026gt; var body: some View { VStack { List { ForEach(categoryGroups, id: \\.id) { group in Text(group.name) /* The change is here */ ForEach(group.categoriesArray, id: \\.id) { category in Text(category.name) } } } } } } "}]