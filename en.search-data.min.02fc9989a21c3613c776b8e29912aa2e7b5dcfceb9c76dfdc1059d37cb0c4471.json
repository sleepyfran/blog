[{"id":0,"href":"/knowledge/docs/swift/formatters/","title":"Formatters","section":"Swift","content":" Formatters # The easiest way to get a formatted element is to use the formatted method that is available on a myriad of data types without the need to instantiate our own formatter. And the best thing is that all these things are also available directly on SwiftUI controls like Text and TextField by using the format parameter.\nBelow are the most common/useful ones I\u0026rsquo;ve found so far.\nDates # In order to get a date formatted, we can simply call formatted on a Date type, which gives us the full, long formatted date:\nDate.now.formatted() // \u0026#34;7/16/2022, 1:15 PM\u0026#34; Of course this by itself is not very useful, but we can customize how we want the date to be shown by adding parameters to the function call. If we add .timeDate as a parameter we\u0026rsquo;ll get the same result, but now we can chain calls in a fluent fashion to customize the output, for example:\nDate.now.formatted( .dateTime.hour().minute() ) // \u0026#34;1:15 PM\u0026#34; Date.now.formatted( .dateTime.year().month() ) // \u0026#34;Jul 2022\u0026#34; You can also pass parameters to each individual component:\nDate.now.formatted( .dateTime.year(.twoDigits).month() ) // \u0026#34;Jul 22\u0026#34; Relative dates # Using the relative parameter, we can get how long it\u0026rsquo;s been in a relative fashion since a date:\nDate.now.addingTimeInterval(-15000).formatted( .relative(presentation: .numeric) ) // \u0026#34;4 hours ago\u0026#34; Date.now.addingTimeInterval(-15000).formatted( .relative(presentation: .numeric) ) Date ranges # If you use formatted on a range of dates, you get the duration between the two dates:\nlet now = Date.now let in16Minutes = Date.now.addingTimeInterval(1000) (now..\u0026lt;in16Minutes).formatted( .components(style: .narrow) ) // \u0026#34;16min 40sec\u0026#34; Currencies # 16.40.formatted(.currency(code: \u0026#34;EUR\u0026#34;)) // \u0026#34;â‚¬16.40\u0026#34; 25.34.formatted(.currency(code: \u0026#34;USD\u0026#34;)) // \u0026#34;$25.34\u0026#34; Sadly for this one it doesn\u0026rsquo;t seem to respect the currency\u0026rsquo;s usual symbol position and instead uses the one specified in the user\u0026rsquo;s location. In my case I have my computer language set to English US which by default positions the symbol in the left side while for Euros the symbol is usually on the right.\nNumeric # 12.formatted(.number.sign(strategy: .always())) // \u0026#34;+12\u0026#34; 12.formatted(.percent) // 12% "},{"id":1,"href":"/knowledge/docs/swift/coredata/errors-and-gotchas/unrecognized-selector-objectatindex/","title":"Unrecognized selector `objectAtIndex`","section":"Errors and gotchas","content":" Unrecognized selector objectAtIndex # 2022-06-21 22:41:30.447763+0200 App[56115:1179524] -[__NSCFSet objectAtIndex:]: unrecognized selector sent to instance 0x600003df9c20 This happened with the following code, basically when trying to do a ForEach on a property coming from a CoreData model:\nimport CoreData import SwiftUI struct BudgetView: View { @FetchRequest(entity: CategoryGroup.entity(), sortDescriptors: []) var categoryGroups: FetchedResults\u0026lt;CategoryGroup\u0026gt; var body: some View { VStack { List { ForEach(categoryGroups, id: \\.id) { group in Text(group.name) ForEach(group.categories, id: \\.id) { category in Text(category.name) } } } } } } This property is actually declared manually as an array:\npublic final class CategoryGroup: NSManagedObject, Identifiable { @NSManaged public var categories: [Category] } But even though I declared it as an array apparently the underlying type that CoreData actually puts there is an NSSet, which by default does not allow to retrieve stuff by its index (does that unrecognized selector objectAtIndex makes a bit more sense now?)\nThe easy solution is to mark the property as \u0026ldquo;Ordered\u0026rdquo; in the CoreData model. The proper solution, however, is to not interact with NSSet directly unless we can avoid it, so we can simply introduce a computed variable that transforms our property into an array (or whatever other data type we need!):\npublic var categoriesArray: [Category] { let set = categories as? Set\u0026lt;Category\u0026gt; ?? [] return set.sorted { $0.id \u0026lt; $1.id } } This casts the NSSet into an array sorting it by their ID. Now instead of doing the ForEach directly on the categories property we have to use this computed one:\nimport CoreData import SwiftUI struct BudgetView: View { @FetchRequest(entity: CategoryGroup.entity(), sortDescriptors: []) var categoryGroups: FetchedResults\u0026lt;CategoryGroup\u0026gt; var body: some View { VStack { List { ForEach(categoryGroups, id: \\.id) { group in Text(group.name) /* The change is here */ ForEach(group.categoriesArray, id: \\.id) { category in Text(category.name) } } } } } } "}]